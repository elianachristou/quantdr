---
title: "quantdr"
author: 
- name: Eliana Christou
  affiliation: University of North Carolina at Charlotte
output: rmarkdown::html_vignette
header-includes: |
  ```{=latex}
  \newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
  ```
vignette: >
  %\VignetteIndexEntry{quantdr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
abstract: "While dimension reduction techniques have been well developed, they focus on the entire conditional distribution of the data.  There are a lot of research areas where extremes are important and require the study of the conditional quantiles of the response given the predictor variables.  `quantdr` is an `R` package that performs dimension reduction to conditional quantiles by determining the directions that span the central quantile subspace (CQS)."  
keywords: "central quantile subspace, dimension reduction, quantile regression"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Data visualization and non-parametric fitting can become very chalennging when data is *high-dimensional*.  This has led to the development of many dimension reduction techniques, which focus on the entire conditional distribution of the data.  However, when specific aspects of the conditional distribution are of interest, these methods can provide more directions than necessary.  

Quantile regession (QR) has received a lot of attention since its inception from Koenker and Bassett (1978) and it has been an attractive tool for research areas where non-central parts of the data are important.  However, dimension reduction techniques for conditional quantiles have recently made an appearance and are still developing.  For some references, see Wu et al. (2010), Christou and Akritas (2016), Kong and Xia (2012, 2014), and Luo et al. (2014).

More recently, Christou (2020) proposed a new technique for finding the fewest linear combinations of the predictor variable $\mathbf{X}$ that contain all the information about the conditional quantile.  To give further intuition, for a univariate response $Y$ and a $p$-dimensional predictor $\mathbf{X}$, the method focuses on finding a $p \times d_{\tau}$ matrix $\mathbf{B}_{\tau}$, where $\tau \in (0, 1)$ and $d_{\tau} \leq p$, such that 
\begin{eqnarray*}
Y \independent Q_{\tau}(Y|\mathbf{X}) | \mathbf{B}_{\tau}^{\top} \mathbf{X},
\end{eqnarray*}
for $Q_{\tau}(Y|\mathbf{X})$ the $\tau$th conditional quantile of $Y$ given $\mathbf{X}$.  The space spanned by $\mathbf{B}_{\tau}$ is called the *$\tau$th quantile dimension reduction subspace* for the regression of $Y$ on $\mathbf{X}$.  The intersection of all $\tau$th dimension reduction subspaces is called the *$\tau$th central quantile subspace* ($\tau$-CQS) and is denoted by $\mathcal{S}_{Q_{\tau}(Y|\mathbf{X})}$.  Therefore, the goal is to identify the directions of $\mathcal{S}_{Q_{\tau}(Y|\mathbf{X})}$ and then form the new sufficient predictors $\mathbf{B}_{\tau}^{\top}\mathbf{X}$.     

The purpose of this vignette is to demonstrate the implementation of the functions appearing in the `quantdr` package, along with some examples.  The main function of the package is `cqs`, which returns the estimated directions of the $\tau$-CQS.  

# Getting Started

To get started you need to first install the package using the command 
```{r, eval=FALSE}
install.packages("quantdr")
```
and then use it during any `R` session using the command
```{r}
library(quantdr)
```
For an overview on the available help files of the package use
```{r, eval=FALSE}
help(package = "quantdr")
```
The package includes the following functions:

* `llqr` Local linear quantile estimation
* `llqrcv` Cross-Validation bandwidth selection for local linear quantile estimation
* `cqs` Central quantile subspace
* `bic_d` Modified-BIC type criterion for structural dimension selection

To get help on a specific function you can type `help(function.name)` or `?function.name` for a convenient shorthand.  Try
```{r, eval=FALSE}
help(cqs)
?cqs
```

To run examples in `R` you can use the examples used to illutrated that the commands are executable by pasting them into the `R` session.

# Central quantile subspace
## Overview

The overall goal of the `cqs` function is to identify the coefficients of the linear combination $\mathbf{B}_{\tau}^{\top}\mathbf{X}$ in order to reduct the $p \times 1$ predictor vector $\mathbf{X}$ to a $d_{\tau} \times 1$ predictor vector $\mathbf{B}_{\tau}^{\top}\mathbf{X}$.  To do that, Christou (2020) proved two important results:

* $\boldsymbol{\beta}_{\tau} \in \mathcal{S}_{Q_{\tau}(Y|\mathbf{X})}$, where $\boldsymbol{\beta}_{\tau}$ is the slope vector from regression the conditional quantile on $\mathbf{X}$, i.e., 
\begin{eqnarray*}
(\alpha_{\tau}, \boldsymbol{\beta}_{\tau}) = \arg \min_{(a_{\tau}, \mathbf{b}_{\tau})} E \{ Q_{\tau}(Y| \mathbf{A}^{\top} \mathbf{X}) - a_{\tau} - \mathbf{b}_{\tau}^{\top}\mathbf{X}\},
\end{eqnarray*}
and $\mathbf{A}$ spans the central subspace (Li 1991).  This implies an initial dimension reduction using $\mathbf{A}$, making the nonparametric estimation of $Q_{\tau}(Y|\mathbf{A}^{\top}\mathbf{X})$ tractable.   

* $E\{Q_{\tau} (Y|U_{\tau})\mathbf{X}\} \in \mathcal{S}_{Q_{\tau}(Y|\mathbf{X})}$, where $U_{\tau}$ is a measurable function of $\mathbf{B}_{\tau}^{\top}\mathbf{X}$, provided that $Q_{\tau}(Y|U_{\tau})\mathbf{X}$ is integrable.  

The above two results imply the following:

1. If the dimension of the $\tau$-CQS is known to be one, then we can fit a linear regression model of $Q_{\tau}(Y|\mathbf{A}^{\top}\mathbf{X})$ on $\mathbf{X}$ and report the slope vector as the basis vector.

1. If the dimension of the $\tau$-CQS is known to be greater than one, then we can set $\boldsymbol{\beta}_{\tau, 0}=\boldsymbol{\beta}_{\tau}$ as the initial vector and then create more vectors using $\boldsymbol{\beta}_{\tau,j}=E\{Q_{\tau}(Y | \boldsymbol{\beta}_{\tau, j-1}^{\top}\mathbf{X})\mathbf{X}\}$, for $j=1, \dots, p-1$.  In order to obtain linearly independent vectors, we can perform an eigenvalue decomposition on $\mathbf{V}_{\tau}\mathbf{V}_{\tau}^{\top}$, where $\mathbf{V}_{\tau}=(\boldsymbol{\beta}_{\tau, 0}, \dots, \boldsymbol{\beta}_{\tau, p-1})$ and choose the eigenvectors corresponding to the $d_{\tau}$ nonzero eigenvalues.  

1. If the dimension of the $\tau$-CQS is unknown, then can apply the procedure from 2. and estimate the dimension $d_{\tau}$ using the modified-BIC type criterion of Zhu et al. (2010). 

All of the above are incorporated in the `cqs` function in `R`.

## The algorithm on a glance

The first step of the algorithm requires to fit a linear regression model of $Q_{\tau}(Y|\mathbf{A}^{\top}\mathbf{X})$ on $\mathbf{X}$, which implies the non-parametric estimation of the conditional quantile.  For this, we use the `llqr` function of the package and apply the local linear conditional quantile estimation technique of Guerre and Sabbah (2012).  The second step of the algorithm relies on estimating a conditional expectation and performing an eigenvalue decomposition.  Specifically,

1.  We use a dimension reduction technique to estimate the basis matrix $\mathbf{A}$ of the central subspace, denoted by $\widehat{\mathbf{A}}$, and form the new sufficient predictors $\widehat{\mathbf{A}}^{\top} \mathbf{X}_{i}$, $i=1, \dots, n$.  For this we use the function `dr` from the package `dr`.

1.  For each $i=1, \dots, n$, we use the local linear conditional quantile estinmation method of Guerre and Sabbah (2012) to estimate $Q_{\tau}(Y|\widehat{\mathbf{A}}^{\top} \mathbf{X}_{i})$.  For this we use the `llqr` of the presented package.

1.  We set $\widehat{\boldsymbol{\beta}}_{\tau}$ to be 
\begin{eqnarray*}
(\widehat{\alpha}_{\tau}, \widehat{\boldsymbol{\beta}}_{\tau}) = \arg \min_{(a_{\tau}, \mathbf{b}_{\tau})} \sum_{i=1}^{n} \{\widehat{Q}_{\tau}(Y|\widehat{\mathbf{A}}^{\top}\mathbf{X}_{i}) - a_{\tau} - \mathbf{b}_{\tau}^{\top} \mathbf{X}_{i}\}^2.
\end{eqnarray*}
For this we use the `lm` function of the `stats` package.

1. If $d_{\tau}=1$ we stop and report $\widehat{\boldsymbol{\beta}}_{\tau}$ as the estimated basis vector for $\mathcal{S}_{Q_{\tau}(Y|\mathbf{X})}$.  Otherwise, we move to Step 5.  

1. We set $\widehat{\boldsymbol{\beta}}_{\tau, 0}=\widehat{\boldsymbol{\beta}}_{\tau}$, and, for $j=1, \dots, p-1$, we
    A.  form the predictors $\widehat{\boldsymbol{\beta}}_{\tau, j-1}^{\top} \mathbf{X}_{i}$, $i=1, \dots, n$ and estimate $Q_{\tau}(Y| \widehat{\boldsymbol{\beta}}_{\tau, j-1}^{\top} \mathbf{X}_{u})$ using the local linear conditional quantile estimation method.  For this we use the `llqr` function of the presented paper.
    A.  form $\widehat{\boldsymbol{\beta}}_{\tau, j} = n^{-1} \sum_{i=1}^{n} \widehat{Q}_{\tau}(Y|\widehat{\boldsymbol{\beta}}_{\tau, j-1}^{\top} \mathbf{X}_{i}) \mathbf{X}_{i}$.
    
1.  We form the $p \times p$ matrix $\widehat{\mathbf{V}}_{\tau}=(\widehat{\boldsymbol{\beta}}_{\tau, 0}, \dots, \widehat{\boldsymbol{\beta}}_{\tau, p-1})$ and choose the $d_{\tau}$ eigenvectors corresponding to the $d_{\tau}$ largest eigenvalues of $\widehat{\mathbf{V}}_{\tau} \widehat{\mathbf{V}}_{\tau}^{\top}$.  For this we use the `eigen` function of the `base` package.  

If $d_{\tau}$ is unknown, then we estimate it using the modified-BIC type criterion of Zhu et al. (2010).  For this we use the `bic_d` function of the presented package.  



# Conclusion

This vignette provides a brief introduction to the R package `quantdr` and presents a tutorial on how to implement the basic function `cqs`.  Performing dimension reduction techniques to conditional quantiles is an active research topic and therefore, updates and new functions will be incorporated into new versions of the package.  For this reason, this document will be updated accordingly and will be made available through the package.  Suggestions and recommendations from the users will be highly appreciated.        

-----

* Make a list
    * with 4 spaces nested
    
1. Ordered list
1. Ordered list

Definition
: say the definition

*italic*
**bold**

```{r, results='hide'}
# if i want to write code
add <- function(a, b) a + b
add(10, 20)
```

```{r, results='asis'}
# if i want to write code
add <- function(a, b) a + b
add(10, 20)
```

Consider submitting the vignette to the Journal of Statistical Software of The R Journal. 

