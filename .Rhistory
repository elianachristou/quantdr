newx <- xstand %*% ahat
d <- d_hat
d
# define the bandwidth and estimate the conditional quantile
h <- sd(y) * n^ (-1 / (d + 4))
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est
beta_hat <- lm(qhat ~ xstand)$coef[-1]
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- tcrossprod(b, b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
bic_d(eigenvalues, n)
eigenvalues
?dr
dr
library(dr)
dr
dr.compute
library(MAVE)
mave
mave.compute
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100; p <- 1
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
test_that("x should be more than one-dimensional", {
set.seed(1234)
n <- 100; p <- 1
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
expect_error(cqs(x, y, tau = tau), )
})
# Example 1
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
cqs(x, y, tau)
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
true_beta
true_beta=cbind(c(1,rep(0,9)), c(0,1,rep(0,8)), c(0,0,1,rep(0,7)))
true_beta
library(pracma)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:2]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:3]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:4]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:5]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:6]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:7]) / (pi/2)
for (i in 1:p){
lambdas[i] = subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
}
lambdas=as.null(p)
for (i in 1:p){
lambdas[i] = subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
}
lambdas
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
i
i=1
bic_d(lambdas, n)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^2 + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^3 + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]+x[,2]^2)  + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]+x[,2]^3)  + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:2])
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:2]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:3]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:4]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:5]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:6]) / (pi / 2)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p - 2))
beta_true / sqrt(sum(beta_true^2))
# sufficient direction
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
# Since dtau is known to be one, the algorithm will produce only one vector
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
apply(out, beta_true, 2, subspace)
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out1 <- cqs(x, y, tau = tau, dtau = 1)
out1
out2 <- cqs(x, y, tau = tau)
out2
out2$qvectors[, 1:out2$dtau]
library(pracma)
beta_true <- c(3, 1, rep(0, p - 2))
beta_hat1 <- out1$qvectors
beta_hat2 <- out2$qvectors[, 1:out2$dtau]
subspace(beta_true, beta_hat1) / (pi / 2)
subspace(beta_true, beta_hat2) / (pi / 2)
newx <- x %*% beta_hat1
qhat1 <- llqr(newx, y, tau)
qhat1
qhat2 <- llqr(newx, y, tau, method = "CV")
qhat2
true_dir <- x %*% beta_true
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", pch = 16)
points(true_dir, qhat1$ll_est, pch = 16, col = 'red')
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
out3 <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out3[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out3
newx <- x %*% out3
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", main = taus[i], pch = 16)
qhat_tau <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(true_dir, qhat_tau, pch = 16, col = "red")
}
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
devtools::load_all()
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
tau = 0.01; y=newy
x <- as.matrix(x)
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- scale(x, scale = FALSE)
sig <- var(x)
signrt <- MTS::msqrt(sig)$invsqrt
xstand <- xc %*% signrt
# use SIR for initial dimension reduction and apply BIC criterion
# to estimate d, the dimension of the central subspace
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
bic_d <- function(lambdas, n) {
lambdas <- sort(lambdas, decreasing = TRUE)
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
return(which(gn == max(gn)))
}
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
devtools::load_all()
rm(list = c("bic_d", "lag"))
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(840, 0.22, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
devtools::load_all()
# Example 1
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
cqs(x, y, tau)
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p - 2))
beta_true / sqrt(sum(beta_true^2))
# sufficient direction
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
# Since dtau is known to be one, the algorithm will produce only one vector
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
# Estimate and plot the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i], pch = 16)
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, pch = 16, col = "red")
}
library(MASS)
attach(Boston)
# read the data
y <- medv
x <- cbind(rm, log(tax), ptratio, log(lstat))
n <- length(y); p <- dim(x)[2]
# plot the estimated coefficient of each predictor variable for multiple quantiles
tau <- seq(0.1, 0.9, by = 0.005)
beta_hat <- matrix(0, p, length(tau))
for (k in 1:length(tau)) {
out <- cqs(x, y, tau = tau[k])
beta_hat[, k] <- out$qvectors[, 1:out$dtau] # the suggested dimension of the central quantile subspace is 1
}
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
library(MASS)
attach(Boston)
# read the data
y <- medv
x <- cbind(rm, log(tax), ptratio, log(lstat))
n <- length(y); p <- dim(x)[2]
# plot the estimated coefficient of each predictor variable for multiple quantiles
tau <- seq(0.1, 0.9, by = 0.005)
beta_hat <- matrix(0, p, length(tau))
for (k in 1:length(tau)) {
out <- cqs(x, y, tau = tau[k])
beta_hat[, k] <- out$qvectors[, 1:out$dtau] # the suggested dimension of the central quantile subspace is 1
}
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
?cqs
devtools::load_all()
?cqs
?lm
?cqs
?llqr
?cqs
?llqr
?cqs
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(840, 0.22, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
comp <- matrix(0, n, length(taus))
dim(qhat)
for (i in 1:length(taus)) {
comp[, i] <- (newy < qhat[, i])
}
apply(comp, 2, mean)
taus
length(newy)
matrix(newy, dim(qhat)[1], dim(qhat)[2])
matrix(newy, dim(qhat)[1], dim(qhat)[2])<qhat
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2])<qhat)
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
?dr
dr(y~x)
library(dr)
dr(y~x)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
dr(y~x)
bic_d(dr(y~x)$evalues, 100)
cqs(x, y, tau = 0.5)
devtools::load_all()
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = "a")
expect_error(llqr(x, y, tau = tau, method = a)
llqr(x, y, tau = tau, method = a)
is.character('cv')
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = a)
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = a)
llqr(x, y, tau = tau, method = 'a')
test_that("the function gives an error message when method is not one of
rule or CV", {
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
expect_error(llqr(x, y, tau = tau, method = 2), )
expect_error(llqr(x, y, tau = tau, method = a), )
expect_error(llqr(x, y, tau = tau, method = 'a'), )
})
?llqr
?cqs
devtools::load_all()
vignette(quantreg)
