tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y[1:(n / 2)], tau = tau)
devtools::load_all()
cqs(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
cqs(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
cqs(x, y, tau = tau, dtau = -1.5)
cqs(x, y, tau = tau, dtau = 1)$dtau
cqs(x, y, tau = tau, dtau = 2.5)
cqs(x, y, tau = tau, dtau = 20)
set.seed(1234)
n <- 100
p <- 1
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
y=matrix(rnorm(100), 2, 50)
y
y=matrix(rnorm(100), 50, 2)
dim(y)[2]
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y[1:(n / 2)], tau = tau)
devtools::load_all()
cqs(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
cqs(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
cqs(x, y, tau = tau, dtau = -1.5)
cqs(x, y, tau = tau, dtau = 1)$dtau
cqs(x, y, tau = tau, dtau = 2.5)
set.seed(1234)
n <- 100
p <- 1
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
llqr(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
x0 <- 1
llqr(x, y, tau = tau, x0 = x0)$ll_est
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- x[, 1]^2 + error
tau <- 0.5
llqrcv(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
devtools::load_all()
n <- 100
x <- rnorm(100)
error <- rnorm(100)
y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
devtools::load_all()
devtools::load_all(".")
mem_used()
microbenchmark(
as.null(1000),
list(),
times = 100
)
library(microbenchmark)
microbenchmark(
as.null(1000),
list(),
times = 100
)
x <- rnorm(100)
microbenchmark(
x - x[1, 1],
x <- list(); x <- x - x[1, 1],
times = 100
)
microbenchmark(
x - x[1, 1],
x <- list()
x <- x - x[1, 1],
times = 100
)
microbenchmark(
x - x[1, 1],
{x <- list()
x <- x - x[1, 1]},
times = 100
)
microbenchmark(
x - x[1],
{x <- list()
x <- x - x[1]},
times = 100
)
x - x[1]
devtools::load_all()
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- 0.5
x0 <- 1
llqr(x, y, tau = tau, x0 = x0)
# Example 3
# estimate the function for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
length(times)
devtools::load_all()\
devtools::load_all()
# estimate the function for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
fit.alt <- llqr(x, y, tau = tau, h=1)
fit.alt
devtools::load_all()
devtools::load_all()
# Example 3
# estimate the function for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
# Example 3
# estimate the function for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(40, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
# Example 3
# estimate the function for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(45, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
microbenchmark(
as.null(10),
list(),
times = 1
)
microbenchmark(
as.null(2),
list(),
times = 1
)
devtools::load_all()
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
devtools::load_all()
devtools::load_all()
library(quantreg)
0.26/6
devtools::load_all()
devtools::load_all()
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors
set.seed(1234)
n <- 100
p <- 10
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p - 2))
beta_true / sqrt(sum(beta_true^2))
# sufficient direction
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
# Since dtau is known to be one, the algorithm will produce only one vector
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out
lapply(subspace, beta_true, out)
?lapply
lapply(beta_true, out, subspace)
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
devtools::check_win_devel()
devtools::install_github("elianachristou/quantdr")
install_github("elianachristou/quantdr")
devtools::install_github("elianachristou/quantdr")
devtools::load_all()
devtools::revdep_check()
use_revdep()
devtools::use_revdep()
devtools::build()
devtools::release()
spell_check()
devtools::spell_check()
devtools::spell_check()
devtools::release()
devtools::check_rhub()
devtools::release()
