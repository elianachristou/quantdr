x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- X %*% out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
newx
plot(3 * x[, 1] + x[, 2], y)
plot(3 * x[, 1] + x[, 2], y)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(3 * x[, 1] + x[, 2]) + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
plot(3 * x[, 1] + x[, 2], y)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
plot(x[, 1] + x[, 2], y)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + 0.5 * x[, 2]) + error
plot(x[, 1] + 0.5 * x[, 2], y)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + 0.5 * x[, 2]) + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
out[1,]
out/out[1,]
cbind(out[1,])
out[1,]
out[,1]/out[1,1]
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
plot(x[, 1] + x[, 2], y)
plot(x[, 1] + x[, 2], y, xlab = "sufficient direction", ylab = "y")
newx[1, ]
newx[, 1]
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
dir1 <- x %*% c(1, 1)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1)
dir1 <- t(x) %*% beta_true
dim(x)
dim(beta_true)
dir1 <- x %*% t(beta_true)
t(beta_true)
dir1 <- x %*% beta_true
beta_true %*% x
beta_true %*% t(x)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
beta_true %*% t(x)
x %*% beta_true
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y")
qhat <- llqr(new, y, tau = taus[i])$ll_est
points(dir1, qhat)
}
i
plot(dir1, y, xlab = "sufficient direction", ylab = "y")
llqr(new, y, tau = taus[i])$ll_est
length(newx)
x %*% out
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y")
qhat <- llqr(new[, i], y, tau = taus[i])$ll_est
points(dir1, qhat)
}
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y")
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat)
}
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y")
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
library(quantdr)
## basic example code
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
library(quantdr)
## basic example code
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
summary(cars)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
?cars
library(quantdr)
## basic example code
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
library(quantdr)
## basic example code
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
library(pracma)
for (i in 1:length(taus)){
subspace(out[, i], dir1)
}
out[, i]
dir1
for (i in 1:length(taus)){
subspace(out[, i], beta_true)
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))/(pi/2)
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3*x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))/(pi/2)
}
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
out[, i]
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3*x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
# true direction that spans each central quantile subspace
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2 }
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2
}
library(MASS)
attach(Boston)
# read the data
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y0); p=dim(x)[2]
library(MASS)
attach(Boston)
# read the data
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y); p=dim(x)[2]
# plot the estimated direction of ech predictor variable for multiple quantiles
tau=seq(0.1, 0.9, by=0.005)
beta_hat=matrix(0,p,length(tau))
length(tau)
k=1
out=cqs(x, y, tau = tau[k])
out
beta_hat[,k]=out$qvectors[, 1:out$dtau]
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y); p=dim(x)[2]
# plot the estimated direction of ech predictor variable for multiple quantiles
tau=seq(0.1, 0.9, by=0.005)
beta_hat=matrix(0,p,length(tau))
for (k in 1:length(tau)){
out=cqs(x, y, tau = tau[k])
beta_hat[,k]=out$qvectors[, 1:out$dtau]
}
par(mfrow=c(1,4))
plot(tau, (signrt%*%beta_hat)[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
par(mfrow=c(1,4))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.30, -0.10))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.15, -0.95))
par(mfrow=c(2,2))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.30, -0.10))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.15, -0.95))
par(mfrow=c(2,2))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.20, 0))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.20, -1))
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficien)
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
lintr::lint_package()
beta_true
beta_true/sqrt(sum(beta_true^2))
library(quantdr)
## basic example code - a homogeneous model
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true/sqrt(sum(beta_true^2))
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
# Estimate and plot the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
?llqr
?llqrcv
?cqs
?bic_D
?bic_d
help(cqs)
?cqs
help(package = "quantdr")
help(package = "quantdr")
?quantdr
??quantdr
example(cqs)
example(cqs)
example(llqr)
example(rq)
library(quantreg)
example(rq)
