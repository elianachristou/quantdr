subspace(beta_true, out1$qvectors) / (pi / 2)
?llqr
newx
true_dir <- x %*% beta_true
length(true_dir)
length(y)
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", pch = 16)
points(true_dir, qhat1, pch = 16, col = 'red')
install.packages('quantmod')
library(quantmod)
?getQuote
getQuote("BTC-USD", what=yahooQR)
getQuote("BTC-USD", what=yahooQF)
getQuote("BTC;USD", what=yahooQF)
getQuote("BTC", what=yahooQF)
getQuote("QQQQ;SPY", what=yahooQF)
getQuote("QQQQ;SPY", what=yahooQF("Last Trade (Prince Only)"))
getQuote("QQQQ;SPY", what=yahooQF("Last Trade (Price Only)"))
getQuote("QQQQ;SPY", what=yahooQF("10 years Trade (Price Only)"))
getQuote("QQQQ;SPY", what=yahooQF("Trade for 10 years (Price Only)"))
?getSymbols
getSymbols("BTC", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
BTC=getSymbols("BTC", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
head(BTC)
BTC=getSymbols("BTC-USD", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
head(BTC)
BTC
library(quantmod)
data_BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(data_BTC)
dim(data_BTC)
BTC=getSymbols("BTC-USD", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
library(quantmod)
data_BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(data_BTC)
dim(data_BTC)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(BTC)
dim(BTC)
names(BTC)
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
n
x
x[1,]
xtemp[,5]
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
y
r
y[1,]
newy
newy[1]
devtools::load_all()
y <- BTC$`BTC-USD.Adjusted`
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
y[1]
r[1]
y[1:2]
digg(log(y[1:2]))
diff(log(y[1:2]))
?diff
library(timeSeries)
?diff
diff(log(y[1:2]))
diff(1:10)
diff(1:10,2)
# get the prices (y) and the returns (r)
y=BIT$Adj.Close
library(MASS)
diff(log(y[1:2]))
length(y)
length(r)
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
devtools::load_all()
names(BTC)
length(BTC$`BTC-USD.Adjusted`)
dim(BTC)
y <- BTC$`BTC-USD.Adjusted`
y[1]
as.vector(y[1])
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
length(r)
r[1]
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, y, tau = taus[1])
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
``
out1$dtau; out2;dtau; out3$dtau
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2;dtau; out3$dtau
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat=cbind(out1$qvectors[, 1], out2$qvectors[, 1], out3$qvectors[, 3])
beta_hat
beta_hat/sqrt(sum(beta^2))
beta_hat/sqrt(sum(beta_hat^2))
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat1
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat2
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
beta_hat3
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
cbind(beta_hat1, beta_hat2, beta_hat3)
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
newx
dim( newx)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])$ll_est
}
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], method = "CV")$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], method = "CV")$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], h = sd(newy) * n^(-1/5))$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
newx[, 1]
qhat
plots.ts(newy)
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
plot.ts(newy)
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
prop <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
prop[, i] <- (newy < qhat[, i])
}
prop
mean(prop[, 1])
taus
mean(prop[, 1])
mean(prop[, 2])
mean(prop[, 3])
apply(mean, 2, prop)
comp <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
comp[, i] <- (newy < qhat[, i])
}
?apply
apply(comp, 2, mean)
apply(comp, 2, mean)
apply(comp, 2, mean)
taus
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
data(mcycle, package="MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
devtools::load_all()
devtools::load_all()
usethis::use_news_md()
devtools::use_travic()
devtools::use_travis()
usethis::use_travis()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
usethis::use_travis()
usethis::use_travis()
devtools::check()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
?dr
help(package='dr')
library(dr)
library(KernSmooth)
library(MTS)
library(mvtnorm)
library(quantreg)
?dr
devtools::load_all()
devtools::load_all()
lintr::lint_package()
lprq
?quantreg.nonpar
library(quantreg.nonpar)
install.packages('quantreg.nonpar')
help(package = quantdr)
?llqr
a=1
length(a)
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
par(mfrow=c(1, 1))
data(mcycle, package="MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
?llqr
?llqr
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
?llqr
?llqr
lintr::lint_package()
# demonstrate the function estimation for different quantile levels
par(mfrow = c(1, 1))
data(mcycle, package = "MASS")
attach(mcycle)
plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit, lty = i)
}
legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
lty=1:length(taus))
?llqr
?llqr
lintr::lint_package()
?llqrcv
?llqrcv
?bic_d
?bic_d
?bic_d
lintr::lint_package()
?cqs
?scale
?eigen
?cqs
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# without specifying d and dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
lintr::lint_package()
devtools::load_all()
devtools::load_all()
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
library(quantdr)
library(quantdr)
help(package = "quantdr")
?llqr
qhat1 <- llqr(newx, y, tau)
newx <- x %*% beta_hat1
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out2 <- cqs(x, y, tau = tau)
out2
out2$qvectors[, 1:out2$dtau]
library(pracma)
beta_true <- c(3, 1, rep(0, p - 2))
beta_hat1 <- out1$qvectors
beta_hat2 <- out2$qvectors[, 1:out2$dtau]
subspace(beta_true, beta_hat1) / (pi / 2)
subspace(beta_true, beta_hat2) / (pi / 2)
newx <- x %*% beta_hat1
qhat1 <- llqr(newx, y, tau)
qhat1
y
?llqrcv
y <- as.vector(BTC$`BTC-USD.Adjusted`)
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag,] <- r[(i - lag):(i-1)]
}
xtemp2 <- cbind(xtemp[,5], xtemp[,4], xtemp[,3], xtemp[,2], xtemp[,1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
length(newy)
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(38, -50, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"))
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(1000, 0.2, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"))
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(1000, 0.2, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(950, 0.2, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(900, 0.2, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(900, 0.2, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
par(mfrow=c(1, 3))
for (i in 1:length(taus)) {
plot.ts(newy, ylab = "returns")
lines(qhat[, i], col = (i+1))
}
par(mfrow=c(1, 3))
for (i in 1:length(taus)) {
plot.ts(newy, ylab = "returns")
lines(qhat[, i], col = (i+1))
}
