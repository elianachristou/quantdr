n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(x, y, main=taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 13)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(x, y, main=taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 1)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(x, y, main=taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, pch = 6)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(x, y, main=taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 6)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(x, y, main=taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
tau = 0.5
x0 = 1
llqr(x, y, tau = tau, x0 = x0)
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
tau = 0.5
x0 = 1
llqr(x, y, tau = tau, x0 = x0)
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
on.exit(par(op))
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
on.exit(layout(1))
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
def.par = par()
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
par(mfrow=c(1,1))
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
tau <- 0.5
lines(times, llqr(times, accel, tau = taus[i], h=0.5)$ll_est ,lty=1)
lines(times, llqr(times, accel, tau = taus[i], method="rule")$ll_est ,lty=2)
lines(times, llqr(times, accel, tau = taus[i], method="CV")$ll_est ,lty=3)
legend(40,-70,c("h=0.5","h=rule","h=CV"), lty=1:3)
set.seed(1234)
n <- 100
x <- rnorm(100); error <- rnorm(100); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.25, 0.5, 0.75)
plot(x, y)
for (i in 1:length(tau)) {
points(x, llqr(x, y, tau=tau[i])$ll_est, col = i)
}
n <- 100
x <- cbind(rnorm(n), rnorm(n)); error <- rnorm(100); y <- x[, 1]^2 + error
x0=1
tau=0.5
llqr(x, y, tau=tau, x0=x0)$ll_est
?mcycle
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
tau = 0.5
x0 = 1
llqr(x, y, tau = tau, x0 = x0)
par(mfrow=c(1, 1))
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
require(MASS)
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
hs <- c(1,2,3,4)
for(i in hs){
h = hs[i]
fit <- lprq(times,accel,h=h,tau=.5)
lines(fit$xx,fit$fv,lty=i)
}
legend(50,-70,c("h=1","h=2","h=3","h=4"),lty=1:length(hs))
par(mfrow=c(1, 1))
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
tau <- 0.5
lines(times, llqr(times, accel, tau = taus[i], h=0.5)$ll_est ,lty=1)
lines(times, llqr(times, accel, tau = taus[i], method="rule")$ll_est ,lty=2)
lines(times, llqr(times, accel, tau = taus[i], method="CV")$ll_est ,lty=3)
legend(40,-70,c("h=0.5","h=rule","h=CV"), lty=1:3)
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- 0.5
h=c(0.5, 'rule', 'CV')
par(mfrow=c(2, 2))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = tau, h=h[i])$ll_est, col = 'red', pch = 16)
}
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- 0.5
h=0.5
par(mfrow=c(2, 2))
plot(x, y)
points(x, llqr(x, y, tau = tau, h=h)$ll_est, col = 'red', pch = 16)
#' plot(x, y)
points(x, llqr(x, y, tau = tau, method='rule')$ll_est, col = 'red', pch = 16)
#' plot(x, y)
points(x, llqr(x, y, tau = tau, method='CV')$ll_est, col = 'red', pch = 16)
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- 0.5
h=0.5
par(mfrow=c(2, 2))
plot(x, y)
points(x, llqr(x, y, tau = tau, h=h)$ll_est, col = 'red', pch = 16)
#' plot(x, y)
points(x, llqr(x, y, tau = tau, method='rule')$ll_est, col = 'red', pch = 16)
#' plot(x, y)
points(x, llqr(x, y, tau = tau, method='CV')$ll_est, col = 'red', pch = 16)
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- 0.5
h=0.5
par(mfrow=c(2, 2))
plot(x, y)
points(x, llqr(x, y, tau = tau, h=h)$ll_est, col = 'red', pch = 16)
plot(x, y)
points(x, llqr(x, y, tau = tau, method='rule')$ll_est, col = 'red', pch = 16)
plot(x, y)
points(x, llqr(x, y, tau = tau, method='CV')$ll_est, col = 'red', pch = 16)
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
tau = 0.5
x0 = 1
llqr(x, y, tau = tau, x0 = x0)
# demonstrate the function estimation for different quantile levels
par(mfrow=c(1, 1))
data(mcycle)
attach(mcycle)
plot(times,accel,xlab = "milliseconds", ylab = "acceleration (in g)")
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
for(i in 1:length(taus)) {
fit <- llqr(times, accel, tau = taus[i])$ll_est
lines(times, fit ,lty=i)
}
legend(38,-50,c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"), lty=1:length(taus))
data("mcycle", package="MASS")
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
x0 <- 1
tau <- 0.5
llqr(x, y, tau = tau, x0 = x0)$ll_est
lintr::lint_package()
lintr::lint_package()
seq_length(5)
seq_len(5)
lintr::lint_package()
lintr::lint_package()
# demonstrate the function estimation for different quantile levels
par(mfrow=c(1, 1))
# require(MASS)
# data(MASS::mcycle)
# attach(mcycle)
# plot(times, accel, xlab = "milliseconds", ylab = "acceleration")
# taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
# for(i in 1:length(taus)) {
# fit <- llqr(times, accel, tau = taus[i])$ll_est
# lines(times, fit ,lty = i)
# }
# legend(38, -50, c("tau=0.1","tau=0.25","tau=0.5","tau=0.75", "tau=0.9"),
# lty=1:length(taus))
test_that("Local linear estimation", {
set.seed(1234)
n <- 100
x <- rnorm(100); error <- rnorm(100); y <- x^2 + error
tau <- c(0.25, 0.5, 0.75)
par(mfrow=c(2,2))
for (i in 1:length(tau)) {
plot(x, y, main=print(tau[i]))
points(x, llqr(x, y, tau=tau[i])$ll_est, pch=16, col='red')
}
})
test_that("the function gives an error message when the dimension of
x0 is less than that of x", {
set.seed(1234)
n <- 100
x <- cbind(rnorm(n), rnorm(n)); error <- rnorm(100); y <- x[, 1]^2 + error
tau <- 0.5
x0 <- 1
expect_error(llqr(x, y, tau=tau, x0=x0)$ll_est, )
})
test_that("the function gives an error message when the dimension of
x0 is less than that of x", {
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
x0 <- 1
expect_error(llqr(x, y, tau = tau, x0 = x0)$ll_est, )
})
lintr::lint_package()
lintr::lint_package()
n <- 100
x <- rnorm(100); error <- rnorm(100); y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
n <- 100
x <- rnorm(100); error <- rnorm(100); y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
install.packages('lintr')
lintr::lint_package()
install.packages('lintr')
lintr::lint_package()
install.packages("lintr")
lintr::lint_package()
# re-load your code and save all open files or use Ctrl+Shift+L
devtools::load_all(".")
# re-load your code and save all open files or use Ctrl+Shift+L
devtools::load_all()
install.packages(c('devtools', 'roxygen2', 'testhat', 'knitr'))
install.packages('rstudioapi')
rstudioapi::isAvailable('0.99.149')
devtools::install_github('r-lib/devtools')
library(devtools)
has_devel()
install.packages(c("devtools", "roxygen2", "testhat", "knitr"))
install.packages("rstudioapi")
install.packages("rstudioapi")
devtools::load_all()
# estimate the function for different quantile levels
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
### USE THAT!
# style of the code - without automatically fixing
# to have 80 characters per line, put the cursor where the comments are and press Ctrl+Shift+/
install.packages('lintr')
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
load.all()
devtools::load_all()
rm(list = c("df"))
devtools::load_all()
rm(list = c("df"))
lintr::lint_package()
?llqr
?llqr
?llqr
lintr::lint_package()
lintr::lint_package()
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.5, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.25, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.75, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.9, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.1, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2] * error
tau <- 0.5
cqs(x, y, tau = 0.5, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau, d = 1, dtau = 1)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
lambdas
bic_d(lambdas, n, dim(x)[2])
gn <- as.null(p)
for (i in seq_len(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
seq_len(lambdas)
lambdas
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau, d = 1, dtau = 1)
cqs(x, y, tau)
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d_hat <- bic_d(lambdas, n, dim(x)[2])
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
lambdas
length(lambdas)
p
gn
bic_d(lambdas, n, dim(x)[2])
bic_d(lambdas, n, dim(x)[2])
