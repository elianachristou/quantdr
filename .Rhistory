points(dir1, qhat, col = "red")
}
library(quantdr)
## basic example code
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of the central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# Estimate the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)){
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
# install.packages("devtools")
devtools::install_github("elianachristou/quantdr")
library(pracma)
for (i in 1:length(taus)){
subspace(out[, i], dir1)
}
out[, i]
dir1
for (i in 1:length(taus)){
subspace(out[, i], beta_true)
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))/(pi/2)
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3*x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true))/(pi/2)
}
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
out[, i]
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3*x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + x[, 2]) + error
# true direction that spans each central quantile subspace
beta_true <- c(1, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)){
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2))
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2 }
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2
}
for (i in 1:length(taus)){
print(subspace(out[, i], beta_true)/(pi/2)) # the angle is measured in radians, so divide by pi/2
}
library(MASS)
attach(Boston)
# read the data
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y0); p=dim(x)[2]
library(MASS)
attach(Boston)
# read the data
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y); p=dim(x)[2]
# plot the estimated direction of ech predictor variable for multiple quantiles
tau=seq(0.1, 0.9, by=0.005)
beta_hat=matrix(0,p,length(tau))
length(tau)
k=1
out=cqs(x, y, tau = tau[k])
out
beta_hat[,k]=out$qvectors[, 1:out$dtau]
y=medv
x=cbind(rm, log(tax), ptratio, log(lstat))
data=cbind(y,x)
n=length(y); p=dim(x)[2]
# plot the estimated direction of ech predictor variable for multiple quantiles
tau=seq(0.1, 0.9, by=0.005)
beta_hat=matrix(0,p,length(tau))
for (k in 1:length(tau)){
out=cqs(x, y, tau = tau[k])
beta_hat[,k]=out$qvectors[, 1:out$dtau]
}
par(mfrow=c(1,4))
plot(tau, (signrt%*%beta_hat)[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
par(mfrow=c(1,4))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.30, -0.10))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.15, -0.95))
par(mfrow=c(2,2))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.30, -0.10))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.15, -0.95))
par(mfrow=c(2,2))
plot(tau, beta_hat[1,],type='l', xlab='Quantile', main='RM', ylab='Coefficient', ylim=c(0.25, 0.45))
plot(tau, beta_hat[2,],type='l',xlab='Quantile', main='log(TAX)', ylab='Coefficient', ylim=c(-0.20, 0))
plot(tau, beta_hat[3,],type='l',xlab='Quantile', main='PTRATIO', ylab='Coefficient', ylim=c(-0.11, -0.09))
plot(tau, beta_hat[4,],type='l',xlab='Quantile', main='log(LSTAT)', ylab='Coefficient', ylim=c(-1.20, -1))
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficien)
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
lintr::lint_package()
beta_true
beta_true/sqrt(sum(beta_true^2))
library(quantdr)
## basic example code - a homogeneous model
# Setting
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p-2))
beta_true/sqrt(sum(beta_true^2))
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], d = 1, dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
# Estimate and plot the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i])
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, col = "red")
}
?llqr
?llqrcv
?cqs
?bic_D
?bic_d
help(cqs)
?cqs
help(package = "quantdr")
help(package = "quantdr")
?quantdr
??quantdr
example(cqs)
example(cqs)
example(llqr)
example(rq)
library(quantreg)
example(rq)
?lm
?eigen
?cqs
dev.tools::load.all()
devtools::load.all()
devtools::load_all()
?cqs
beta_true
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out1 <- cqs(x, y, tau = tau, d = 1, dtau = 1)
out1
out2 <- cqs(x, y, tau = tau)
out2
out2$qvectors[, 1:out2$dtau]
library(pracma)
beta_true <- c(3, 1, rep(0, p-2))
beta_hat <- out2$qvectors[, 1:out2$dtau]
beta_true
subspace(beta_true, beta_hat)
subspace(beta_true, out1$qvectors)
library(pracma)
beta_true <- c(3, 1, rep(0, p-2))
beta_hat <- out2$qvectors[, 1:out2$dtau]
subspace(beta_true, beta_hat) / (pi / 2)
subspace(beta_true, out1$qvectors) / (pi / 2)
?llqr
newx
true_dir <- x %*% beta_true
length(true_dir)
length(y)
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", pch = 16)
points(true_dir, qhat1, pch = 16, col = 'red')
install.packages('quantmod')
library(quantmod)
?getQuote
getQuote("BTC-USD", what=yahooQR)
getQuote("BTC-USD", what=yahooQF)
getQuote("BTC;USD", what=yahooQF)
getQuote("BTC", what=yahooQF)
getQuote("QQQQ;SPY", what=yahooQF)
getQuote("QQQQ;SPY", what=yahooQF("Last Trade (Prince Only)"))
getQuote("QQQQ;SPY", what=yahooQF("Last Trade (Price Only)"))
getQuote("QQQQ;SPY", what=yahooQF("10 years Trade (Price Only)"))
getQuote("QQQQ;SPY", what=yahooQF("Trade for 10 years (Price Only)"))
?getSymbols
getSymbols("BTC", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
BTC=getSymbols("BTC", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
head(BTC)
BTC=getSymbols("BTC-USD", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
head(BTC)
BTC
library(quantmod)
data_BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(data_BTC)
dim(data_BTC)
BTC=getSymbols("BTC-USD", from = "2016-12-31", to = "2017-12-31", auto.assign=FALSE)
library(quantmod)
data_BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(data_BTC)
dim(data_BTC)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", auto.assign = FALSE)
head(BTC)
dim(BTC)
names(BTC)
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
n
x
x[1,]
xtemp[,5]
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
y
r
y[1,]
newy
newy[1]
devtools::load_all()
y <- BTC$`BTC-USD.Adjusted`
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- BTC$`BTC-USD.Adjusted`
r <- diff(log(y))
y[1]
r[1]
y[1:2]
digg(log(y[1:2]))
diff(log(y[1:2]))
?diff
library(timeSeries)
?diff
diff(log(y[1:2]))
diff(1:10)
diff(1:10,2)
# get the prices (y) and the returns (r)
y=BIT$Adj.Close
library(MASS)
diff(log(y[1:2]))
length(y)
length(r)
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
devtools::load_all()
names(BTC)
length(BTC$`BTC-USD.Adjusted`)
dim(BTC)
y <- BTC$`BTC-USD.Adjusted`
y[1]
as.vector(y[1])
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
length(r)
r[1]
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
newy=r[-c(1:5)]
n <- length(newy); p <- 10
xtemp=matrix(0,n,5)
for (i in 6:(n+5)){
xtemp[i-5,]=r[(i-5):(i-1)]
}
xtemp2=cbind(xtemp[,5],xtemp[,4],xtemp[,3],xtemp[,2],xtemp[,1])
x=cbind(xtemp2,abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, y, tau = taus[1])
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
``
out1$dtau; out2;dtau; out3$dtau
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2;dtau; out3$dtau
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat=cbind(out1$qvectors[, 1], out2$qvectors[, 1], out3$qvectors[, 3])
beta_hat
beta_hat/sqrt(sum(beta^2))
beta_hat/sqrt(sum(beta_hat^2))
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat1
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat2
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
beta_hat3
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
cbind(beta_hat1, beta_hat2, beta_hat3)
beta_hat1 <- out1$qvectors[, 1] / sqrt(sum(out1$qvectors[, 1]^2))
beta_hat2 <- out2$qvectors[, 1] / sqrt(sum(out2$qvectors[, 1]^2))
beta_hat3 <- out3$qvectors[, 1] / sqrt(sum(out3$qvectors[, 1]^2))
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
newx
dim( newx)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])$ll_est
}
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i])$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], method = "CV")$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], method = "CV")$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx, newy, tau = taus[i], h = sd(newy) * n^(-1/5))$ll_est
}
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
newx[, 1]
qhat
plots.ts(newy)
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
plot.ts(newy)
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
prop <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
prop[, i] <- (newy < qhat[, i])
}
prop
mean(prop[, 1])
taus
mean(prop[, 1])
mean(prop[, 2])
mean(prop[, 3])
apply(mean, 2, prop)
comp <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
comp[, i] <- (newy < qhat[, i])
}
?apply
apply(comp, 2, mean)
apply(comp, 2, mean)
apply(comp, 2, mean)
taus
