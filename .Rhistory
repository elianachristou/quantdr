set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^3 + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]^3 + x[, 2]) + error
tau <- 0.5
cqs(x, y, tau)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]^2 + x[, 2]) + error
tau <- 0.5
cqs(x, y, tau)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1] + 1/x[, 2]) + error
tau <- 0.5
cqs(x, y, tau)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- cos(3 * x[, 1] / 2) + x[, 2]^3 / 2 + error
tau <- 0.5
cqs(x, y, tau)
b <- matrix(0, p, p)
b[, 1] <- beta_hat
j=2
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
hatq[i]
xstand[i, ]
hatq[i] * xstand[i, ]
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
apply(mat, 2, mean)
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- tcrossprod(b, b)
eigenvalues <- eigen(B)$values
eigenvalues
B
eigenvalues
out <- eigen(B)$vectors
out
out <- signrt %*% out
out
bic_d(eigenvalues, n)
eigenvalues
plot(eigenvalues)
lambdas <- eigenvallues
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
lambdas[1:i]
(lambdas[1:i])^2
0.91315436^2
0.26428301^2
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
(n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
devtools::load_all()
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
lambdas <- cqs(x, y, tau)$qvalues
lambdas
plot(lambdas)
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
(n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.5 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.25 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.15 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.1 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.05 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.01 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
devtools::load_all()
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^3 + error
tau <- 0.5
cqs(x, y, tau)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + x[, 2]^3 + error
tau <- 0.5
cqs(x, y, tau)
plot(cqs(x, y, tau)$qvalues)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + exp(x[, 2]) + error
tau <- 0.5
cqs(x, y, tau)
plot(cqs(x, y, tau)$qvalues)
plot(cqs(x, y, tau)$qvalues)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + exp(x[, 2]) + error
tau <- 0.5
cqs(x, y, tau)$qvalues
plot(cqs(x, y, tau)$qvalues)
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]/(0.5 + (x[, 2] + 1.5)^2) + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
cqs(x, y, tau)
plot(cqs(x, y, tau)$qvalues)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
x <- as.matrix(x)
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- scale(x, scale = FALSE)
sig <- var(x)
signrt <- MTS::msqrt(sig)$invsqrt
xstand <- xc %*% signrt
xc
apply(xc, 2, mean)
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- scale(x, scale = FALSE)
sig <- var(x)
signrt <- MTS::msqrt(sig)$invsqrt
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
output
output$evalues
bic_d <- function(lambdas, n) {
lambdas <- sort(lambdas, decreasing = TRUE)
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
0.5 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
return(which(gn == max(gn)))
}
bic_d(lambdas, n)
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
h <- sd(y) * n^ (-1 / (d + 4))
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est
beta_hat <- lm(qhat ~ xstand)$coef[-1]
beta_hat
true_beta <- cbind(c(1,rep(0,9)), c(0,1,rep(0,8)), c(0,0,1,rep(0,7)))
true_beta
library(pracma)
subspace(output$evectors[, 1:3], true_beta) / (pi / 2)
output$evectors[, 1:3]
output$evectors[, 1:3]
beta_hat
devtools::load_all()
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
x <- as.matrix(x)
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- scale(x, scale = FALSE)
sig <- var(x)
signrt <- MTS::msqrt(sig)$invsqrt
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n)
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
# define the bandwidth and estimate the conditional quantile
h <- sd(y) * n^ (-1 / (d + 4))
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est
beta_hat <- lm(qhat ~ xstand)$coef[-1]
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- tcrossprod(b, b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
bic_d(eigenvalues, n)
eigenvalues
?dr
dr
library(dr)
dr
dr.compute
library(MAVE)
mave
mave.compute
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100; p <- 1
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
test_that("x should be more than one-dimensional", {
set.seed(1234)
n <- 100; p <- 1
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
expect_error(cqs(x, y, tau = tau), )
})
# Example 1
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
cqs(x, y, tau)
# Example 2
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1] + exp(x[, 2]) + x[, 3]^3 + error
tau <- 0.5
true_beta
true_beta=cbind(c(1,rep(0,9)), c(0,1,rep(0,8)), c(0,0,1,rep(0,7)))
true_beta
library(pracma)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:2]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:3]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:4]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:5]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:6]) / (pi/2)
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:7]) / (pi/2)
for (i in 1:p){
lambdas[i] = subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
}
lambdas=as.null(p)
for (i in 1:p){
lambdas[i] = subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
}
lambdas
subspace(true_beta, cqs(x, y, tau)$qvectors[,1:i]) / (pi/2)
i
i=1
bic_d(lambdas, n)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^2 + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^3 + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]+x[,2]^2)  + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]+x[,2]^3)  + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:2])
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:2]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:3]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:4]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:5]) / (pi / 2)
subspace(cbind(c(1,rep(0,9)), c(0,1,rep(0,8))), cqs(x, y, tau)$qvectors[, 1:6]) / (pi / 2)
set.seed(1234)
n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p - 2))
beta_true / sqrt(sum(beta_true^2))
# sufficient direction
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
# Since dtau is known to be one, the algorithm will produce only one vector
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
apply(out, beta_true, 2, subspace)
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
set.seed(1234)
n <- 100; p <- 10; tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out1 <- cqs(x, y, tau = tau, dtau = 1)
out1
out2 <- cqs(x, y, tau = tau)
out2
out2$qvectors[, 1:out2$dtau]
library(pracma)
beta_true <- c(3, 1, rep(0, p - 2))
beta_hat1 <- out1$qvectors
beta_hat2 <- out2$qvectors[, 1:out2$dtau]
subspace(beta_true, beta_hat1) / (pi / 2)
subspace(beta_true, beta_hat2) / (pi / 2)
newx <- x %*% beta_hat1
qhat1 <- llqr(newx, y, tau)
qhat1
qhat2 <- llqr(newx, y, tau, method = "CV")
qhat2
true_dir <- x %*% beta_true
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", pch = 16)
points(true_dir, qhat1$ll_est, pch = 16, col = 'red')
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
out3 <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out3[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out3
newx <- x %*% out3
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(true_dir, y, xlab = "sufficient direction", ylab = "y", main = taus[i], pch = 16)
qhat_tau <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(true_dir, qhat_tau, pch = 16, col = "red")
}
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
