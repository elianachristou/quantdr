- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
seq_len(lambdas)
lambdas
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau, d = 1, dtau = 1)
cqs(x, y, tau)
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d_hat <- bic_d(lambdas, n, dim(x)[2])
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
lambdas
length(lambdas)
p
gn
bic_d(lambdas, n, dim(x)[2])
bic_d(lambdas, n, dim(x)[2])
devtools::load_all()
rm(list = c("df"))
devtools::load_all()
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
cqs(x, y, tau, d = 1, dtau = 1)
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
non_par <- llqr(newx, y, tau = tau, method = "CV")
qhat <- non_par$ll_est; h <- h
llqr(newx, y, tau = tau, method = "CV")
devtools::load_all()
rm(list = c("df"))
devtools::load_all()
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
ahat <- cbind(dr::dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% ahat
d=1
ahat <- cbind(dr::dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% ahat
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
h=0.5
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
beta_hat <- lm(qhat ~ xstand)$coef[-1]
beta_hat
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
dtau=1
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
out
CQS <- function(x, y, tau = 0.5, d, dtau, h, method = "rule") {
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
# use SIR for initial dimension reduction
# apply BIC criterion if d is not specified
if (missing(d)) {
output <- dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- BIC_d(lambdas, n, dim(x)[2])
Ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% Ahat
d <- d_hat
} else {
Ahat <- cbind(dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% Ahat
}
# define the bandwidth, if missing.
if (missing(h)) {
if (method == "CV") {
non_par <- llqr(newx, y, tau = tau)
Qhat <- non_par$ll_est; h <- non_par$h
}
if (method == "rule") {
h <- dpill(newx, y);
h <- h * (tau * (1 - tau) / (dnorm(qnorm(tau)))^2)^.2
non_par <- llqr(newx, y, tau = tau, h = h)
Qhat <- non_par$ll_est; h <- h
}
} else {
non_par <- llqr(newx, y, tau = tau, h = h)
Qhat <- non_par$ll_est; h <- h
}
# define the initial vector, i.e., the ordinary least squares estimator from
# regressing Qhat on x
beta_hat <- lm(Qhat ~ xstand)$coef[-1]
# if dtau is missing, use the iterative procedure to produce all vectors
# apply the BIC criterion to determine dtau
if (missing(dtau)) {
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h, )$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
dtau <- BIC_d(eigenvalues, n, dim(x)[2])
list(out = out, eigenvalues = eigenvalues, d = d, dtau_hat = dtau, h = h)
} else if (dtau > 1) {
# if dtau is known to be greater than 1, then use the iterative procedure to
# produce more vectors and select the eigenvectors associated with the dtau
# largest eigenvalues
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
list(out = out, eigenvalues = eigenvalues, d = d, dtau_hat = dtau, h = h)
} else {
# if dtau is known to be one, then the initial vector is sufficient
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
list(out = out, d = d, dtau_hat = dtau, h = h)
}
}
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
out <- cqs(x, y, tau = tau, d = 1, dtau = 1)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
cqs <- function(x, y, tau = 0.5, d, dtau, h, method = "rule") {
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
# use SIR for initial dimension reduction
# apply BIC criterion if d is not specified
if (missing(d)) {
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
} else {
ahat <- cbind(dr::dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% ahat
}
# define the bandwidth, if missing.
if (missing(h)) {
if (method == "CV") {
non_par <- llqr(newx, y, tau = tau)
qhat <- non_par$ll_est; h <- non_par$h
}
if (method == "rule") {
h <- KernSmooth::dpill(newx, y);
h <- h * (tau * (1 - tau) / (dnorm(qnorm(tau)))^2)^.2
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
} else {
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
# define the initial vector, i.e., the ordinary least squares estimator from
# regressing qhat on x
beta_hat <- lm(qhat ~ xstand)$coef[-1]
# if dtau is missing, use the iterative procedure to produce all vectors
# apply the BIC criterion to determine dtau
if (missing(dtau)) {
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h, )$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
dtau <- bic_d(eigenvalues, n, dim(x)[2])
list(out = out, eigenvalues = eigenvalues, d = d, dtau_hat = dtau, h = h)
} else if (dtau > 1) {
# if dtau is known to be greater than 1, then use the iterative procedure to
# produce more vectors and select the eigenvectors associated with the dtau
# largest eigenvalues
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
list(out = out, eigenvalues = eigenvalues, d = d, dtau_hat = dtau, h = h)
} else {
# if dtau is known to be one, then the initial vector is sufficient
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
list(out = out, d = d, dtau_hat = dtau, h = h)
}
}
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
cqs <- function(x, y, tau = 0.5, d, dtau, h, method = "rule") {
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
# use SIR for initial dimension reduction
# apply BIC criterion if d is not specified
if (missing(d)) {
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
} else {
ahat <- cbind(dr::dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% ahat
}
# define the bandwidth, if missing.
if (missing(h)) {
if (method == "CV") {
non_par <- llqr(newx, y, tau = tau)
qhat <- non_par$ll_est; h <- non_par$h
}
if (method == "rule") {
h <- KernSmooth::dpill(newx, y);
h <- h * (tau * (1 - tau) / (dnorm(qnorm(tau)))^2)^.2
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
} else {
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
# define the initial vector, i.e., the ordinary least squares estimator from
# regressing qhat on x
beta_hat <- lm(qhat ~ xstand)$coef[-1]
# if dtau is missing, use the iterative procedure to produce all vectors
# apply the BIC criterion to determine dtau
if (missing(dtau)) {
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h, )$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
dtau <- bic_d(eigenvalues, n, dim(x)[2])
list(evectors = out, evalues = eigenvalues, d = d, dtau = dtau, h = h)
} else if (dtau > 1) {
# if dtau is known to be greater than 1, then use the iterative procedure to
# produce more vectors and select the eigenvectors associated with the dtau
# largest eigenvalues
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
list(evectors = out, evalues = eigenvalues, d = d, dtau = dtau, h = h)
} else {
# if dtau is known to be one, then the initial vector is sufficient
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
list(evectors = out, d = d, dtau_hat = dtau, h = h)
}
}
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
cqs <- function(x, y, tau = 0.5, d, dtau, h, method = "rule") {
# define the parameters
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
# use SIR for initial dimension reduction
# apply BIC criterion if d is not specified
if (missing(d)) {
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
} else {
ahat <- cbind(dr::dr(y ~ xstand)$evector[, 1:d])
newx <- xstand %*% ahat
}
# define the bandwidth, if missing.
if (missing(h)) {
if (method == "CV") {
non_par <- llqr(newx, y, tau = tau)
qhat <- non_par$ll_est; h <- non_par$h
}
if (method == "rule") {
h <- KernSmooth::dpill(newx, y);
h <- h * (tau * (1 - tau) / (dnorm(qnorm(tau)))^2)^.2
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
} else {
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est; h <- h
}
# define the initial vector, i.e., the ordinary least squares estimator from
# regressing qhat on x
beta_hat <- lm(qhat ~ xstand)$coef[-1]
# if dtau is missing, use the iterative procedure to produce all vectors
# apply the BIC criterion to determine dtau
if (missing(dtau)) {
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h, )$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
dtau <- bic_d(eigenvalues, n, dim(x)[2])
list(evectors = out, evalues = eigenvalues, d = d, dtau = dtau, h = h)
} else if (dtau > 1) {
# if dtau is known to be greater than 1, then use the iterative procedure to
# produce more vectors and select the eigenvectors associated with the dtau
# largest eigenvalues
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
list(evectors = out, evalues = eigenvalues, d = d, dtau = dtau, h = h)
} else {
# if dtau is known to be one, then the initial vector is sufficient
out <- signrt %*% beta_hat
out <- out / sqrt(sum(out^2))
dtau <- dtau
list(evectors = out, d = d, dtau_hat = dtau, h = h)
}
}
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$evectors / out$evectors[1]
