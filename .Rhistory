n <- 100; p <- 10; taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
# true direction that spans each central quantile subspace
beta_true <- c(3, 1, rep(0, p - 2))
beta_true / sqrt(sum(beta_true^2))
# sufficient direction
dir1 <- x %*% beta_true
# Estimate the directions of each central quantile subspace
# Since dtau is known to be one, the algorithm will produce only one vector
out <- matrix(0, p, length(taus))
for (i in 1:length(taus)) {
out[, i] <- cqs(x, y, tau = taus[i], dtau = 1)$qvectors
}
out
# compare the estimated direction with the true one using the angle between the two subspaces
library(pracma)
for (i in 1:length(taus)) {
print(subspace(out[, i], beta_true) / (pi / 2)) # the angle is measured in radians, so divide by pi/2
}
# Estimate and plot the conditional quantile function using the new sufficient predictors
newx <- x %*% out
par(mfrow=c(2,3))
for (i in 1:length(taus)) {
plot(dir1, y, xlab = "sufficient direction", ylab = "y", main = taus[i], pch = 16)
qhat <- llqr(newx[, i], y, tau = taus[i])$ll_est
points(dir1, qhat, pch = 16, col = "red")
}
library(MASS)
attach(Boston)
# read the data
y <- medv
x <- cbind(rm, log(tax), ptratio, log(lstat))
n <- length(y); p <- dim(x)[2]
# plot the estimated coefficient of each predictor variable for multiple quantiles
tau <- seq(0.1, 0.9, by = 0.005)
beta_hat <- matrix(0, p, length(tau))
for (k in 1:length(tau)) {
out <- cqs(x, y, tau = tau[k])
beta_hat[, k] <- out$qvectors[, 1:out$dtau] # the suggested dimension of the central quantile subspace is 1
}
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
library(MASS)
attach(Boston)
# read the data
y <- medv
x <- cbind(rm, log(tax), ptratio, log(lstat))
n <- length(y); p <- dim(x)[2]
# plot the estimated coefficient of each predictor variable for multiple quantiles
tau <- seq(0.1, 0.9, by = 0.005)
beta_hat <- matrix(0, p, length(tau))
for (k in 1:length(tau)) {
out <- cqs(x, y, tau = tau[k])
beta_hat[, k] <- out$qvectors[, 1:out$dtau] # the suggested dimension of the central quantile subspace is 1
}
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
par(mfrow=c(2,2))
plot(tau, beta_hat[1, ], type = 'l', xlab = 'Quantile', main = 'RM', ylab = 'Coefficient')
plot(tau, beta_hat[2, ], type = 'l', xlab = 'Quantile', main = 'log(TAX)', ylab = 'Coefficient')
plot(tau, beta_hat[3, ], type = 'l', xlab = 'Quantile', main = 'PTRATIO', ylab = 'Coefficient')
plot(tau, beta_hat[4, ], type = 'l', xlab = 'Quantile', main = 'log(LSTAT)', ylab = 'Coefficient')
?cqs
devtools::load_all()
?cqs
?lm
?cqs
?llqr
?cqs
?llqr
?cqs
library(quantmod)
BTC <- getSymbols("BTC-USD", from = "2016-01-01", to = "2018-12-31", src = "yahoo", auto.assign = FALSE)
head(BTC)
dim(BTC)
y <- as.vector(BTC$`BTC-USD.Adjusted`)
r <- diff(log(y))
lag <- 5
newy <- r[ - c(1:lag)]
n <- length(newy); p <- 10
xtemp <- matrix(0, n, lag)
for (i in (lag + 1):(n + lag)){
xtemp[i - lag, ] <- r[(i - lag):(i - 1)]
}
xtemp2 <- cbind(xtemp[, 5], xtemp[, 4], xtemp[, 3], xtemp[, 2], xtemp[, 1])
x <- cbind(xtemp2, abs(xtemp2))
dim(x)
taus <- c(0.01, 0.025, 0.05)
out1 <- cqs(x, newy, tau = taus[1])
out2 <- cqs(x, newy, tau = taus[2])
out3 <- cqs(x, newy, tau = taus[3])
out1$dtau; out2$dtau; out3$dtau
beta_hat1 <- out1$qvectors[, 1]
beta_hat2 <- out2$qvectors[, 1]
beta_hat3 <- out3$qvectors[, 1]
beta_hat <- cbind(beta_hat1, beta_hat2, beta_hat3)
newx <- x %*% beta_hat
qhat <- matrix(0, n, length(taus))
for (i in 1:length(taus)) {
qhat[, i] <- llqr(newx[, i], newy, tau = taus[i])$ll_est
}
plot.ts(newy, ylab = "returns")
lines(qhat[, 1], col = "red")
lines(qhat[, 2], col = "blue")
lines(qhat[, 3], col = "green")
legend(840, 0.22, c("tau=0.01","tau=0.025","tau=0.05"), col=c("red", "blue", "green"), lty = 1)
comp <- matrix(0, n, length(taus))
dim(qhat)
for (i in 1:length(taus)) {
comp[, i] <- (newy < qhat[, i])
}
apply(comp, 2, mean)
taus
length(newy)
matrix(newy, dim(qhat)[1], dim(qhat)[2])
matrix(newy, dim(qhat)[1], dim(qhat)[2])<qhat
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2])<qhat)
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
colMeans(matrix(newy, dim(qhat)[1], dim(qhat)[2]) < qhat)
taus
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
?dr
dr(y~x)
library(dr)
dr(y~x)
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
dr(y~x)
bic_d(dr(y~x)$evalues, 100)
cqs(x, y, tau = 0.5)
devtools::load_all()
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = "a")
expect_error(llqr(x, y, tau = tau, method = a)
llqr(x, y, tau = tau, method = a)
is.character('cv')
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = a)
devtools::load_all()
llqr(x, y, tau = tau, method = 2)
llqr(x, y, tau = tau, method = a)
llqr(x, y, tau = tau, method = 'a')
test_that("the function gives an error message when method is not one of
rule or CV", {
set.seed(1234)
n <- 100; p <- 2
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
expect_error(llqr(x, y, tau = tau, method = 2), )
expect_error(llqr(x, y, tau = tau, method = a), )
expect_error(llqr(x, y, tau = tau, method = 'a'), )
})
?llqr
?cqs
devtools::load_all()
vignette(quantreg)
bic_d <- function(lambdas, n) {
lambdas <- sort(lambdas, decreasing = TRUE)
p <- length(lambdas)
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
which(gn == max(gn))
}
bic_d(c(1,2,3,4), 100)
bic_d(c(1,1,3,4), 100)
bic_d(c(1,1,1,4), 100)
bic_d(c(1,1,1,1), 100)
bic_d(c(1,1,4,5), 100)
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100
p <- 10
tau <- 0.5
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out <- cqs(x, y, tau)
bic_d(out$qvalues, n)
test_that("the BIC criterion correctly estimates the dimension", {
set.seed(1234)
n <- 100
p <- 10
tau <- 0.5
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out <- cqs(x, y, tau)
expect_equal(bic_d(out$qvalues, n), 1)
})
set.seed(1234)
n <- 100
p <- 10
tau <- 0.5
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
out <- cqs(x, y, tau)
bic_d(out$qvalues, n)
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y[1:(n / 2)], tau = tau)
devtools::load_all()
cqs(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
cqs(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
cqs(x, y, tau = tau, dtau = -1.5)
cqs(x, y, tau = tau, dtau = 1)$dtau
cqs(x, y, tau = tau, dtau = 2.5)
cqs(x, y, tau = tau, dtau = 20)
set.seed(1234)
n <- 100
p <- 1
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, dtau = 1)
out
# without specifying dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
y=matrix(rnorm(100), 2, 50)
y
y=matrix(rnorm(100), 50, 2)
dim(y)[2]
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y[1:(n / 2)], tau = tau)
devtools::load_all()
cqs(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
cqs(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
cqs(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
cqs(x, y, tau = tau, dtau = -1)
cqs(x, y, tau = tau, dtau = -1.5)
cqs(x, y, tau = tau, dtau = 1)$dtau
cqs(x, y, tau = tau, dtau = 2.5)
set.seed(1234)
n <- 100
p <- 1
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
cqs(x, y, tau = tau)
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x^2 + error
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
llqr(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqr(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
x0 <- 1
llqr(x, y, tau = tau, x0 = x0)$ll_est
devtools::load_all()
devtools::load_all()
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
p <- 2
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n)
y <- x[, 1]^2 + error
tau <- 0.5
llqrcv(x, y[1:(n / 2)], tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- -0.1
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
y[1] <- 0 / 0
tau <- 0.5
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 100
x <- rnorm(n)
error <- rnorm(n)
y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
tau <- c(0.2, 0.5)
llqrcv(x, y, tau = tau)
set.seed(1234)
n <- 20
p <- 40
x <- matrix(rnorm(n * p), n, p)
error <- rnorm(n); y <- x[, 1]^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
devtools::load_all()
n <- 100
x <- rnorm(100)
error <- rnorm(100)
y <- x^2 + error
tau <- 0.5
llqrcv(x, y, tau = tau)
devtools::load_all()
