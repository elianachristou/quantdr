sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
h <- sd(y) * n^ (-1 / (d + 4))
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est
# define the initial vector, i.e., the ordinary least squares estimator from
# regressing qhat on x
beta_hat <- lm(qhat ~ xstand)$coef[-1]
beta_hat
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
out <- eigen(B)$vectors
out <- signrt %*% out
eigenvalues
dtau <- bic_d(eigenvalues, n, dim(x)[2])
dtau
eigenvalues
lambdas=eigenvalues
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
lambdas
n
p
newx
is.matrix(newx)
bic_d(eigenvalues, n, dim(newx)[2])
dim(newx)[2]
p=1
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
lambdas
#' @examples
#' set.seed(1234)
#' n <- 100; p <- 10
#' x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
#' y <- 3 * x[, 1] + x[, 2] + error
#' tau <- 0.5
#' out <- cqs(x, y, tau, d = 1, dtau = 1)
#' out
#' 3 * out$qvectors / out$qvectors[1]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$qvectors / out$qvectors[1]
#' out <- cqs(x, y, tau)
#' out
out
out <- cqs(x, y, tau)
out
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
d_hat
bic_d(lambdas, n, dim(x)[2])
lambdas
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
mean(xstand)
output <- dr::dr(y ~ xstand)
output
lambdas <- output$evalues
lambdas
bic_d(lambdas, n, dim(x)[2])
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2)
- 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
i=1
i=3
(lambdas[1:i])^2
lambdas[1:3]
0.83385089^2
0.9131544^2
0.2642830^2
0.2193285^2
bic_d(lambdas, n, dim(x)[2])
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$qvectors / out$qvectors[1]
cqs(x, y, tau)
cqs(x, y, ta)
cqs(x, y, tau)
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
lambdas
bic_d(lambdas, n, dim(x)[2])
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) - 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
devtools::load_all()
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) - 2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
devtools::load_all()
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
3 * out$qvectors / out$qvectors[1]
cqs(x, y, tau)
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# without defining d and dtau
out <- cqs(x, y, tau)
out
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^2 + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2]^3 + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + 1/x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
source('~/quantdr/R/cqs.R', echo=TRUE)
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- center(x)
sig <- var(x)
signrt <- matpower(sig, -1 / 2)
xstand <- xc %*% signrt
output <- dr::dr(y ~ xstand)
lambdas <- output$evalues
d_hat <- bic_d(lambdas, n, dim(x)[2])
ahat <- cbind(output$evectors[, 1:d_hat])
newx <- xstand %*% ahat
d <- d_hat
d
lambdas
h <- sd(y) * n^ (-1 / (d + 4))
non_par <- llqr(newx, y, tau = tau, h = h)
qhat <- non_par$ll_est
beta_hat <- lm(qhat ~ xstand)$coef[-1]
b <- matrix(0, p, p)
b[, 1] <- beta_hat
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
eigenvalues
out <- eigen(B)$vectors
out <- signrt %*% out
dtau <- bic_d(eigenvalues, n, dim(x)[2])
dtau
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
lambdas=eigenvalues
eigenvalues
gn <- as.null(p)
for (i in 1:length(lambdas)) {
gn[i] <- n * sum((lambdas[1:i])^2) / sum((lambdas)^2) -
2 * (n^ (3 / 4) / p) * i * (i + 1) / 2
}
gn
b <- matrix(0, p, p)
b[, 1] <- beta_hat
b
for (j in 2:(dim(x)[2])) {
newx <- xstand %*% b[, j - 1]
hatq <- llqr(newx, y, tau = tau, h = h)$ll_est
mat <- matrix(0, dim(x)[1], dim(x)[2])
for (i in 1:(dim(x)[1])) {
mat[i, ] <- hatq[i] * xstand[i, ]
}
b[, j] <- apply(mat, 2, mean)
}
b
B <- b %*% t(b)
eigenvalues <- eigen(B)$values
eigenvalues
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# without defining d and dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 2, dtau = 2)
out
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau, d = 2, dtau = 2)$qvectors[, 1:2]
# estimate the directions of a multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- exp(x[, 1]) + x[, 2] + error
tau <- 0.5
cqs(x, y, tau)$qvectors[, 1:2]
# estimate the directions of a heteroscedastic multi-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- x[, 1]^3 + exp(x[, 2]) + x[, 3] * error
tau <- 0.5
cqs(x, y, tau, d = 2, dtau = 2)
tau <- 0.5
out <- cqs(x, y, tau)
tau <- 0.25
out <- cqs(x, y, tau)
out
tau <- 0.9
out <- cqs(x, y, tau)
out
devtools::load_all()
rm(list = c("cqs"))
devtools::load_all()
center(x)
center <- function(x) {
return(t(t(x) - apply(x, 2, mean)))
}
center(x)
scale(x, scale = FALSE)
center(x) == scale(x, scale = FALSE)
devtools::load_all()
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# without defining d and dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
devtools::load_all()
# estimate the directions of a single-index model
set.seed(1234)
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# estimate the function for different quantile levels
set.seed(1234)
n <- 100
x <- rnorm(n); error <- rnorm(n); y <- (x + 1)^3 + 0.1 * (x - 2)^3 + error
taus <- c(0.1, 0.25, 0.5, 0.75, 0.9)
par(mfrow=c(2, 3))
for (i in 1:length(taus)) {
plot(x, y, main = taus[i])
points(x, llqr(x, y, tau = taus[i])$ll_est, col = 'red', pch = 16)
}
devtools::load_all()
rm(list = c("df"))
devtools::load_all()
quantdr::df
?df
devtools::load_all()
?df()
?quantdr::df()
quantdr::df
warnings()
rm(list = ls())
devtools::load_all()
rm(df)
devtools::load_all()
quantreg::rq
devtools::load_all()
n <- 100; p <- 10
x <- matrix(rnorm(n * p), n, p); error <- rnorm(n)
y <- 3 * x[, 1] + x[, 2] + error
tau <- 0.5
out <- cqs(x, y, tau, d = 1, dtau = 1)
out
# without defining d and dtau
out <- cqs(x, y, tau)
out
out$qvectors[, 1:out$dtau]
n <- length(y); p <- dim(x)[2]
# standardize the predictor variables
xc <- scale(x, scale = FALSE)
sig <- var(x)
msqrt(sig)
install.packages('MTS')
library(MTS)
msqrt(sig)
msqrt(sig)
msqrt(sig)m1=
m1=msqrt(sig)
names(m1)
m1$invsqrt
matpower(sig, -1 / 2)
matpower <- function(a, alpha) {
a <- (a + t(a)) / 2
tmp <- eigen(a)
return(tmp$vectors %*% diag((tmp$values)^alpha) %*%
t(tmp$vectors))
}
m1$invsqrt
matpower(sig, -1 / 2)
matpower(sig, -1 / 2) == m1$invsqrt
devtools::load_all()
devtools::load_all()
